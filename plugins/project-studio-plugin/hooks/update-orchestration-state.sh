#!/bin/bash
# Update orchestration state file after key events
# Usage: update-orchestration-state.sh <action> <args...>
#
# Actions:
#   session-start           - Mark new session started
#   session-end             - Mark session ended with summary
#   phase-start <phase>     - Mark phase as in_progress
#   phase-complete <phase>  - Mark phase as completed
#   gate-check <phase> <passed> [issues...] - Record gate check result
#   agent-start <agent> <mode> <phase>      - Record agent execution start
#   agent-complete <agent> <output_file>    - Record agent completion
#   feature-update <feature-id> <status>    - Update feature status
#   add-decision <id> <question> <phase>    - Add pending decision
#   resolve-decision <id> <choice>          - Mark decision resolved
#   add-blocker <id> <description> <phase>  - Add blocker
#   resolve-blocker <id>                    - Remove blocker

set -e

# Find project root (look for .project-studio directory or docs/)
find_project_root() {
    local dir="$PWD"
    while [ "$dir" != "/" ]; do
        if [ -d "$dir/.project-studio" ] || [ -d "$dir/docs" ]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    echo "$PWD"
}

PROJECT_ROOT=$(find_project_root)
STATE_DIR="$PROJECT_ROOT/.project-studio"
STATE_FILE="$STATE_DIR/state.yaml"

# Ensure state directory exists
ensure_state_dir() {
    if [ ! -d "$STATE_DIR" ]; then
        mkdir -p "$STATE_DIR"
        echo "üìÅ Created .project-studio directory"
    fi
}

# Initialize state file if it doesn't exist
init_state_file() {
    if [ ! -f "$STATE_FILE" ]; then
        cat > "$STATE_FILE" << 'EOF'
# Orchestration State
# Auto-generated by Project Studio
schema_version: 1

workflow:
  type: null
  started_at: null
  started_by: "user"

phase:
  current: null
  current_number: 0
  status: "not_started"
  continue_phase: null
  add_feature_step: null

phases_completed:
  discovery: false
  ai_workflow: false
  architecture: false
  design: false
  planning: false
  development: false
  quality: false
  codebase_analysis: false
  skill_discovery: false
  infer_prd: false
  infer_architecture: false
  infer_design: false
  ai_tooling_audit: false

gate_checks: []
sessions: []

current_session:
  session_id: null
  started_at: null
  phases_worked: []
  artifacts_modified: []
  pending_work: null

agent_runs: []

features:
  total: 0
  in_planning: 0
  in_development: 0
  completed: 0
  items: []

pending:
  decisions: []
  blockers: []
  questions: []

resume_context:
  last_action: null
  next_recommended: null
  key_decisions_made: []
  open_questions: []

artifacts: {}

preferences:
  auto_commit: true
  auto_gate_check: false
  verbosity: "normal"
  skip_confirmations: false
EOF
        echo "üìã Initialized orchestration state file"
    fi
}

# Get current timestamp in ISO format
timestamp() {
    date -u +"%Y-%m-%dT%H:%M:%SZ"
}

# Generate a simple session ID
generate_session_id() {
    echo "session-$(date +%Y%m%d-%H%M%S)"
}

# Use yq if available, otherwise fall back to sed-based updates
has_yq() {
    command -v yq &> /dev/null
}

# Update a simple value in the YAML file using sed (for systems without yq)
update_yaml_value() {
    local key="$1"
    local value="$2"
    local file="$STATE_FILE"

    if has_yq; then
        yq -i "$key = \"$value\"" "$file"
    else
        # Simple sed-based replacement for flat keys
        # This is a simplified approach - complex nested updates need yq
        echo "‚ö†Ô∏è  yq not found - state update may be incomplete"
        echo "   Install yq for full state management: brew install yq"
    fi
}

# Main action handling
ACTION="$1"
shift || true

case "$ACTION" in
    "session-start")
        ensure_state_dir
        init_state_file
        SESSION_ID=$(generate_session_id)
        TS=$(timestamp)

        if has_yq; then
            yq -i ".current_session.session_id = \"$SESSION_ID\"" "$STATE_FILE"
            yq -i ".current_session.started_at = \"$TS\"" "$STATE_FILE"
            yq -i ".current_session.phases_worked = []" "$STATE_FILE"
            yq -i ".current_session.artifacts_modified = []" "$STATE_FILE"
            yq -i ".current_session.pending_work = null" "$STATE_FILE"
        fi

        echo "‚úÖ Session started: $SESSION_ID"
        ;;

    "session-end")
        SUMMARY="${1:-Session ended}"
        TS=$(timestamp)

        if has_yq; then
            # Archive current session to history
            yq -i ".current_session.ended_at = \"$TS\"" "$STATE_FILE"
            yq -i ".current_session.summary = \"$SUMMARY\"" "$STATE_FILE"
            yq -i ".sessions += [.current_session]" "$STATE_FILE"

            # Reset current session
            yq -i ".current_session = {\"session_id\": null, \"started_at\": null, \"phases_worked\": [], \"artifacts_modified\": [], \"pending_work\": null}" "$STATE_FILE"
        fi

        echo "‚úÖ Session ended and archived"
        ;;

    "phase-start")
        PHASE="$1"
        TS=$(timestamp)

        if has_yq; then
            yq -i ".phase.current = \"$PHASE\"" "$STATE_FILE"
            yq -i ".phase.status = \"in_progress\"" "$STATE_FILE"
            yq -i ".current_session.phases_worked += [\"$PHASE\"]" "$STATE_FILE"
        fi

        echo "üîÑ Phase started: $PHASE"
        ;;

    "phase-complete")
        PHASE="$1"

        if has_yq; then
            # Convert phase name to key format (e.g., "ai-workflow" -> "ai_workflow")
            PHASE_KEY=$(echo "$PHASE" | tr '-' '_')
            yq -i ".phases_completed.$PHASE_KEY = true" "$STATE_FILE"
            yq -i ".phase.status = \"completed\"" "$STATE_FILE"
        fi

        echo "‚úÖ Phase completed: $PHASE"
        ;;

    "gate-check")
        PHASE="$1"
        PASSED="$2"
        shift 2
        ISSUES="$*"
        TS=$(timestamp)

        if has_yq; then
            # Create gate check entry
            GATE_ENTRY="{\"phase\": \"$PHASE\", \"checked_at\": \"$TS\", \"passed\": $PASSED, \"issues\": []}"
            yq -i ".gate_checks += [$GATE_ENTRY]" "$STATE_FILE"

            # Add issues if any
            if [ -n "$ISSUES" ] && [ "$PASSED" = "false" ]; then
                for issue in $ISSUES; do
                    yq -i ".gate_checks[-1].issues += [\"$issue\"]" "$STATE_FILE"
                done
            fi
        fi

        if [ "$PASSED" = "true" ]; then
            echo "‚úÖ Gate check passed: $PHASE"
        else
            echo "‚ùå Gate check failed: $PHASE"
        fi
        ;;

    "agent-start")
        AGENT="$1"
        MODE="$2"
        PHASE="$3"
        TS=$(timestamp)

        if has_yq; then
            AGENT_ENTRY="{\"agent\": \"$AGENT\", \"mode\": \"$MODE\", \"phase\": \"$PHASE\", \"started_at\": \"$TS\", \"completed_at\": null, \"output_file\": null, \"status\": \"running\"}"
            yq -i ".agent_runs += [$AGENT_ENTRY]" "$STATE_FILE"
        fi

        echo "ü§ñ Agent started: $AGENT ($MODE)"
        ;;

    "agent-complete")
        AGENT="$1"
        OUTPUT_FILE="$2"
        TS=$(timestamp)

        if has_yq; then
            # Find the most recent running entry for this agent and update it
            yq -i "(.agent_runs | map(select(.agent == \"$AGENT\" and .status == \"running\")) | .[-1]).completed_at = \"$TS\"" "$STATE_FILE"
            yq -i "(.agent_runs | map(select(.agent == \"$AGENT\" and .status == \"running\")) | .[-1]).output_file = \"$OUTPUT_FILE\"" "$STATE_FILE"
            yq -i "(.agent_runs | map(select(.agent == \"$AGENT\" and .status == \"running\")) | .[-1]).status = \"completed\"" "$STATE_FILE"

            # Track artifact modification
            yq -i ".current_session.artifacts_modified += [\"$OUTPUT_FILE\"]" "$STATE_FILE"
        fi

        echo "‚úÖ Agent completed: $AGENT -> $OUTPUT_FILE"
        ;;

    "workflow-type")
        WORKFLOW_TYPE="$1"
        TS=$(timestamp)

        if has_yq; then
            yq -i ".workflow.type = \"$WORKFLOW_TYPE\"" "$STATE_FILE"
            yq -i ".workflow.started_at = \"$TS\"" "$STATE_FILE"
        fi

        echo "üìã Workflow type set: $WORKFLOW_TYPE"
        ;;

    "feature-update")
        FEATURE_ID="$1"
        STATUS="$2"

        if has_yq; then
            # Update feature status
            yq -i "(.features.items[] | select(.id == \"$FEATURE_ID\")).status = \"$STATUS\"" "$STATE_FILE"

            # Recalculate totals
            yq -i ".features.in_planning = [.features.items[] | select(.status == \"planning\")] | length" "$STATE_FILE"
            yq -i ".features.in_development = [.features.items[] | select(.status == \"in_development\")] | length" "$STATE_FILE"
            yq -i ".features.completed = [.features.items[] | select(.status == \"completed\")] | length" "$STATE_FILE"
        fi

        echo "üì¶ Feature updated: $FEATURE_ID -> $STATUS"
        ;;

    "set-resume-context")
        LAST_ACTION="$1"
        NEXT_RECOMMENDED="$2"

        if has_yq; then
            yq -i ".resume_context.last_action = \"$LAST_ACTION\"" "$STATE_FILE"
            yq -i ".resume_context.next_recommended = \"$NEXT_RECOMMENDED\"" "$STATE_FILE"
        fi

        echo "üìù Resume context updated"
        ;;

    "add-decision")
        DECISION_ID="$1"
        QUESTION="$2"
        PHASE="$3"
        TS=$(timestamp)

        if has_yq; then
            DECISION_ENTRY="{\"id\": \"$DECISION_ID\", \"question\": \"$QUESTION\", \"context\": \"\", \"options\": [], \"phase\": \"$PHASE\", \"created_at\": \"$TS\"}"
            yq -i ".pending.decisions += [$DECISION_ENTRY]" "$STATE_FILE"
        fi

        echo "‚ùì Decision added: $DECISION_ID"
        ;;

    "resolve-decision")
        DECISION_ID="$1"
        CHOICE="$2"

        if has_yq; then
            # Remove from pending and add to key decisions
            yq -i "del(.pending.decisions[] | select(.id == \"$DECISION_ID\"))" "$STATE_FILE"
            yq -i ".resume_context.key_decisions_made += [\"$CHOICE\"]" "$STATE_FILE"
        fi

        echo "‚úÖ Decision resolved: $DECISION_ID"
        ;;

    "status")
        # Print current state summary
        if [ -f "$STATE_FILE" ]; then
            echo "üìä Orchestration State Summary"
            echo "==============================="

            if has_yq; then
                echo ""
                echo "Workflow: $(yq '.workflow.type // "not started"' "$STATE_FILE")"
                echo "Current Phase: $(yq '.phase.current // "none"' "$STATE_FILE")"
                echo "Phase Status: $(yq '.phase.status' "$STATE_FILE")"
                echo ""
                echo "Session: $(yq '.current_session.session_id // "none"' "$STATE_FILE")"
                echo "Started: $(yq '.current_session.started_at // "n/a"' "$STATE_FILE")"
                echo ""
                echo "Pending Decisions: $(yq '.pending.decisions | length' "$STATE_FILE")"
                echo "Pending Blockers: $(yq '.pending.blockers | length' "$STATE_FILE")"
            else
                echo "Install yq for detailed status output"
                echo "State file: $STATE_FILE"
            fi
        else
            echo "No orchestration state found"
            echo "Run a /new-project or /continue-project command to start"
        fi
        ;;

    *)
        echo "Usage: update-orchestration-state.sh <action> [args...]"
        echo ""
        echo "Actions:"
        echo "  session-start              - Mark new session started"
        echo "  session-end <summary>      - Mark session ended"
        echo "  phase-start <phase>        - Start a phase"
        echo "  phase-complete <phase>     - Complete a phase"
        echo "  gate-check <phase> <bool>  - Record gate check result"
        echo "  agent-start <agent> <mode> <phase>  - Start agent"
        echo "  agent-complete <agent> <file>       - Complete agent"
        echo "  workflow-type <type>       - Set workflow type"
        echo "  feature-update <id> <status>        - Update feature"
        echo "  set-resume-context <last> <next>    - Set resume info"
        echo "  status                     - Show current state"
        exit 1
        ;;
esac
